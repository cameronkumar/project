void vis::calculateIntersection(int id, vector<idOverVecLen> inter) {
	
	stringstream sInter; // will hold human readable intersection details
	sInter << setprecision(4); // setting precision for doubles
	// get the centre coordinates and radius for calculations
	Point cen = objCentre.at(id); 
	double rad = objRadius.at(id);
	
	if((int)inter.size() == 0) // case of no intersections
		sInter << "Sphere " << id << " does not intersect any other objects!\n";
	else { 
		// loop through all intersections and append string with information
		for(int i = 0; i < (int)inter.size(); i++) {
			
			// read intersection details from vector for calculations
			idOverVecLen currentInt = inter.at(i);
		
			if(inter.at(i).over == 0.0) { // tangent case
			
				// calculating tangent point
				Point pTangent = (Point){cen.x+rad*currentInt.vec.x, // x
						 	 cen.y+rad*currentInt.vec.y, // y
						 	 cen.z+rad*currentInt.vec.z};// z
				// write to intersection string
				sInter << "Sphere " << id << " is tangent to sphere " << currentInt.id << " at point ("
				       << pTangent.x << ", " << pTangent.y << ", " << pTangent.z << ")\n";
				// add tangent to intersection vector for drawing, relatively small radius
				coi.push_back((intDraw){pTangent, currentInt.vec, 0.0, id, i});
				       
				
			} else { 
				
				// get radius of intersecting sphere
				double iRad = objRadius.at(currentInt.id);
				// now calculate the distance from the centre of sphere i to coi 
				double coiDist = pow(currentInt.len, 2) - (pow(iRad,2) - pow(rad,2));
				coiDist = coiDist/(2*currentInt.len);
				// also calculate the radius using the distance calculation as this is a part of the equation
				double coiRad = sqrt(pow(rad,2) - pow(coiDist,2));
				// use this to calculate the centre of the circle
				Point coiCen = (Point){cen.x + coiDist*currentInt.vec.x,
					       	       cen.y + coiDist*currentInt.vec.y,
					       	       cen.z + coiDist*currentInt.vec.z};
				
				// case of tangency between one sphere inside another
				if(rad == iRad + currentInt.len || rad == iRad - currentInt.len) { 
					
					// write tangency string
					sInter << "Sphere " << id << " is tangent to sphere " << currentInt.id << " at point ("
					       << coiCen.x << ", " << coiCen.y << ", " << coiCen.z << ")\n";
					// add to vector
					coi.push_back((intDraw){coiCen, currentInt.vec,  0.0, id, i}); 		
					
					// write to intersection string
					
				} else if(rad < iRad + currentInt.len) { // intersection case
				
					// write to intersection string
					sInter << "Sphere " << id << " intersects sphere " << currentInt.id 
				       	       << " with circle of intersection located about (" << coiCen.x << ", " 
				               << coiCen.y << ", " << coiCen.z << ") with radius " << coiRad << "\n";	
					// add intersection to intersection vector for drawing
					coi.push_back((intDraw){coiCen, currentInt.vec, coiRad, id, i});
				
				}
				
				// nothing done if sphere completely contained in another sphere
				 			
			}
		}	
	}
	return; 
}
